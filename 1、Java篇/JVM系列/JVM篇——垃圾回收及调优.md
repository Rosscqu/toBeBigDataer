## JVM篇——垃圾回收及调优



### 1、判断对象是否存活的方法

#### 1.1 引用计数



缺点：如果对象之间相互引用，那么对象无法清除，即产生内存泄漏；

#### 1.2 可达性分析



可以作为GC roots的对象：

- 当前正在执行的方法的局部变量和输入参数；
- 活动线程
- 所有类的静态字段
- JNI引用



### 2、垃圾清除方法

#### 2.1 标记-清除算法

标记：遍历所有的可达对象，并在本地内存中分门别类记下；

清除：清除不可达对象所占用的内存，在之后进行内存分配时可以重用。



#### 2.2 标记-复制算法



#### 2.3 标记-整理算法





### 3、分代理论



分代假说：

- 大部分新生对象很快无用；
- 存活较长时间的对象，可能存活更长的时间



基于分代假说，将堆内存划分为新生代和老年代，其中新生代划分为Eden区、S0区、S1区。针对不同类型对象不同区域，采用不同策略进行处理。



#### 3.1 Eden区

对象分配是在Eden区，标记阶段Eden区存活的对象就会复制到存活区。存活时间超过一定YGC后（默认15次）后，就会将对象移动到老年代。



#### 3.2 老年代

老年代默认都是存活对象，采用复制-整理的方法：

标记所有通过GC Root可达的对象；

删除所有不可达对象；

整理老年代空间中的内容，方法是将所有存活对象复制，从老年代空间开始的地方依次存放。

默认情况下：Eden:S0:S1=8:1:1



### 4、垃圾收集器



#### 4.1 Serial GC/ParNew GC

1）垃圾回收原理：对新生代使用标记-复制算法，对老年代使用标记-整理算法；

2）垃圾回收步骤：



3）使用场景：适合只有几百M堆内存的JVM，而且是单核CPU时比较有用



4）优点：

- CPU使用率高

5）缺点：

- 暂停时间长，垃圾回收效率低

6）设置：

- -XX：+UseSericalGC配置SerialGC
- -XX:+UseParNewGC配置并行版本的Serial GC，可以配合CMS使用



#### 4.2 并行GC

1）垃圾回收原理：对新生代使用标记-复制算法，对老年代使用标记-整理算法；

2）垃圾回收步骤：



3）使用场景：适用于多核服务器，主要目标是增加吞吐量



4）优点：

- 吞吐量大



5）缺点：

- 新生代和老年代的垃圾回收都会触发STW事件

6）相关设置

- -XX：+UseParallelGC
- -XX:+UseParallelOldGC
- -XX:+UseParallelGC -XX:+UseParallelOldGC
- -XX:+ParallelGCThread=N 指定GC线程数，默认CPU核心数



#### 4.3 CMS

1）垃圾回收原理：使用标记-清除算法

2）设计目标：避免在老年代垃圾回收时出现长时间卡顿，主要通过两种手段：

- 不对老年代进行整理，而是使用空闲列表来管理内存空间的回收；
- 在标记-清除阶段的大部分工作和应用线程一起并发执行



3）回收步骤



4）应用场景



5）优点



6）缺点



7）设置

-XX:+UseConcMarkSweepGC





#### 4.4 G1







